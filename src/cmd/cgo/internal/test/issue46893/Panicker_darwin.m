// Objective-C API for talking to command-line-arguments Go package.
//   gobind -lang=objc command-line-arguments
//
// File is generated by gobind. Do not edit.

#include <Foundation/Foundation.h>
#include "seq.h"
#include "_cgo_export.h"
#include "Panicker.objc.h"


@implementation PanickerPanickerImpl {
}

- (nonnull instancetype)initWithRef:(_Nonnull id)ref {
	self = [super init];
	if (self) { __ref = ref; }
	return self;
}

- (nonnull instancetype)init {
	self = [super init];
	if (self) {
		__ref = go_seq_from_refnum(new_panicker_PanickerImpl());
	}
	return self;
}

- (NSData* _Nullable)panic:(NSData* _Nullable)b error:(NSError* _Nullable* _Nullable)error {
	int32_t refnum = go_seq_go_to_refnum(self._ref);
	nbyteslice _b = go_seq_from_objc_bytearray(b, 0);
	struct proxypanicker_PanickerImpl_Panic_return res = proxypanicker_PanickerImpl_Panic(refnum, _b);
	if (![b isKindOfClass:[NSMutableData class]]) {
	  free(_b.ptr);
	}
	NSData *_ret0_ = go_seq_to_objc_bytearray(res.r0, 1);
	Universeerror* _error = nil;
	GoSeqRef* _error_ref = go_seq_from_refnum(res.r1);
	if (_error_ref != NULL) {
		_error = _error_ref.obj;
		if (_error == nil) {
			_error = [[Universeerror alloc] initWithRef:_error_ref];
		}
	}
	if (_error != nil && error != nil) {
		*error = _error;
	}
	if (_error != nil) {
		return nil;
	}
	return _ret0_;
}

@end


@implementation PanickerPanicker {
}

- (nonnull instancetype)initWithRef:(id)ref {
	self = [super init];
	if (self) { __ref = ref; }
	return self;
}

- (NSData* _Nullable)panic:(NSData* _Nullable)p0 error:(NSError* _Nullable* _Nullable)error {
	int32_t refnum = go_seq_go_to_refnum(self._ref);
	nbyteslice _p0 = go_seq_from_objc_bytearray(p0, 0);
	struct proxypanicker_Panicker_Panic_return res = proxypanicker_Panicker_Panic(refnum, _p0);
	if (![p0 isKindOfClass:[NSMutableData class]]) {
	  free(_p0.ptr);
	}
	NSData *_ret0_ = go_seq_to_objc_bytearray(res.r0, 1);
	Universeerror* _error = nil;
	GoSeqRef* _error_ref = go_seq_from_refnum(res.r1);
	if (_error_ref != NULL) {
		_error = _error_ref.obj;
		if (_error == nil) {
			_error = [[Universeerror alloc] initWithRef:_error_ref];
		}
	}
	if (_error != nil && error != nil) {
		*error = _error;
	}
	if (_error != nil) {
		return nil;
	}
	return _ret0_;
}

@end



void PanickerInit(void) {
	proxypanicker__Init();
}

struct cproxypanicker_Panicker_Panic_return cproxypanicker_Panicker_Panic(int32_t refnum, nbyteslice p0) {
	@autoreleasepool {
		PanickerPanicker* o = go_seq_objc_from_refnum(refnum);
		NSData *_p0 = go_seq_to_objc_bytearray(p0, 0);
		NSData* _Nullable ret0_;
		NSError* error = nil;
		ret0_ = [o panic:_p0 error:&error];
		nbyteslice _ret0_ = go_seq_from_objc_bytearray(ret0_, 1);
		NSError *_error = nil;
		if (error != nil) {
			_error = error;
		}
		int32_t __error;
		if ([_error conformsToProtocol:@protocol(goSeqRefInterface)]) {
			id<goSeqRefInterface> _error_proxy = (id<goSeqRefInterface>)(_error);
			__error = go_seq_go_to_refnum(_error_proxy._ref);
		} else {
			__error = go_seq_to_refnum(_error);
		}
		cproxypanicker_Panicker_Panic_return _sres = {
		  _ret0_, __error
		};
		return _sres;
	}
}

__attribute__((constructor)) static void init() {
	init_seq();
}
